# You Should be able to Copy and Paste this into a powershell terminal and it should just work.
# To end the loop you have to kill the powershell terminal. ctrl-c wont work :/ 



# Http Server
$http = [System.Net.HttpListener]::new() 

# Hostname and port to listen on
$http.Prefixes.Add("http://10.0.0.9:9999/")

# Start the Http Server 
$http.Start()



# Log ready message to terminal 
if ($http.IsListening) {
    write-host " HTTP Server Ready!  " -f 'black' -b 'gre'
    write-host "try testing the different route examples: " -f 'y'
    write-host "$($http.Prefixes)" -f 'y'
    write-host "$($http.Prefixes)some/form" -f 'y'
}


# INFINTE LOOP
# Used to listen for requests
while ($http.IsListening) {



    # Get Request Url
    # When a request is made in a web browser the GetContext() method will return a request object
    # Our route examples below will use the request object properties to decide how to respond
    $context = $http.GetContext()


    # ROUTE EXAMPLE 1
    # http://127.0.0.1/
    if ($context.Request.HttpMethod -eq 'GET' -and $context.Request.RawUrl -eq '/') {

        # We can log the request to the terminal
        write-host "$($context.Request.RemoteEndPoint)  =>  $($context.Request.Url)" -f 'mag'

        # the html/data you want to send to the browser
        # you could replace this with: [string]$html = Get-Content "C:\some\path\index.html" -Raw
        [string]$html = "<h1>A Powershell Webserver</h1><p>home page</p><br><form method='post' action='/quit'><input type='submit' value='Quit'></form>
        <br><form method='post' action='/command'><input type='submit' value='Command'></form>" 
        
        #resposed to the request
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($html) # convert htmtl to bytes
        $context.Response.ContentLength64 = $buffer.Length
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length) #stream to broswer
        $context.Response.OutputStream.Close() # close the response
    
    }

    $form = "<form action='/command' method='post'>
            <p>Powershell prompt</p>
            <p>command</p>
            <textarea rows='4' cols='50' name='command'></textarea>
            <br>
            <input type='submit' value='Submit'>
        </form><form method='post' action='/quit'><input type='submit' value='Quit'></form>"

    # ROUTE EXAMPLE 2
    # http://localhost:8080/some/form'
    if ($context.Request.HttpMethod -eq 'GET' -and $context.Request.RawUrl -eq '/command') {

        # We can log the request to the terminal
        write-host "$($context.Request.RemoteEndPoint)  =>  $($context.Request.Url)" -f 'mag'

        [string]$html = $form
        

        #resposed to the request
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($html) 
        $context.Response.ContentLength64 = $buffer.Length
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length) 
        $context.Response.OutputStream.Close()
    }

    if ($context.Request.HttpMethod -eq 'post' -and $context.Request.RawUrl -eq '/quit')
    {
            [string]$html = '<html><head><meta http-equiv="refresh" content="0; URL=/" /></head></html>'

        #resposed to the request
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($html) 
        $context.Response.ContentLength64 = $buffer.Length
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length) 
        $context.Response.OutputStream.Close()
        $http.Close()
    }

    # ROUTE EXAMPLE 3
    # http://localhost:8080/some/post'
    if ($context.Request.HttpMethod -eq 'POST' -and $context.Request.RawUrl -eq '/command') {
        <#
        # decode the form post
        # html form members need 'name' attributes as in the example!
        $FormContent = [System.IO.StreamReader]::new($context.Request.InputStream).ReadToEnd()

        # We can log the request to the terminal
        write-host "$($context.Request.RemoteEndPoint)  =>  $($context.Request.Url)" -f 'mag'

        Write-Host $FormContent -f 'Green'

        # the html/data
        [string]$html = "<h1>A Powershell Webserver</h1><p>Post Successful!</p>" 

        #resposed to the request
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($html)
        $context.Response.ContentLength64 = $buffer.Length
        $context.Response.OutputStream.Write($buffer, 0, $buffer.Length)
        $context.Response.OutputStream.Close() 
        #>

        
        $request = $context.Request
        $Parameters = @{}
        # Output the request to host
        Write-Host $request | fl * | Out-String

        # Parse Parameters from url
        $rawParameter = [System.IO.StreamReader]::new($context.Request.InputStream).ReadToEnd()
        write-host $rawParameter
        if ($rawParameter) {
                $Parameter = $rawParameter.Split("=")

                $Parameters.Add($Parameter[0], $Parameter[1])
           
        }

        # Create output string (dirty html)
        $output = "<html><body><p>"
        $output = $output + $form
        $Path = (pwd).Path | Out-String
        foreach ($Parameter in $Parameters.GetEnumerator()) {
            
            $command = $Parameter.Value | Out-String
            $command = $command.replace("+", " ")
            $command = $command.replace("%3A", ":")
            $command = $command.replace("%5C", "\")
        
            $output = $output + "Your command is: $($command)" + "<br />"
            if($command) {
            
            $invoke_command = Invoke-Expression $command | Out-String
            $Path = (pwd).Path | Out-String
            $output = $output + "Path is $Path" + "<br />"
            $output = $output + "Output:" + "<br />" + $invoke_command
            }
        }

        $output = $output + "</p></body></html>"
        # Send response
        $statusCode = 200
        $response = $context.Response
        $response.StatusCode = $statusCode    
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($output)
        $response.ContentLength64 = $buffer.Length
        $output = $response.OutputStream
        $output.Write($buffer,0,$buffer.Length)
        $output.Close()
    }


    # powershell will continue looping and listen for new requests...

} 